%{

#include "hw3_output.hpp"

extern int yylineno;
extern int yylex();
void yyerror(const char* message);

%}

%code requires 
{
    #include "abstract_syntax.hpp" 
    #include "generic_syntax.hpp" 
    #include "expression_syntax.hpp"
    #include "statement_syntax.hpp" 
}

%union 
{ 
    int                                       num;
    char*                                     str;
    root_syntax*                              root;
    type_syntax*                              type;                  
    formal_syntax*                            formal;     
    function_declaration_syntax*              function;            
    statement_syntax*                         statement; 	
    expression_syntax*                        expression;  
    list_syntax<formal_syntax>*               formal_list;		         
    list_syntax<function_declaration_syntax>* function_list;	
    list_syntax<statement_syntax>*            statement_list;
    list_syntax<expression_syntax>*           expression_list;                
 };

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token <num> NUM
%token <str> ID
%token <str> STRING

%right ASSIGN
%nonassoc IF // TODO: VERIFY IF IN RIGHT POSITION
%left OR
%left AND
%left <str> EQOP
%left <str> RELOP
%left <str> ADDOP
%left <str> MULOP
%right NOT
%right LPAREN
%left RPAREN
%left ELSE

%type <root>            Program
%type <function_list>   Funcs
%type <function>        FuncDecl
%type <type>            RetType
%type <formal_list> 	Formals
%type <formal_list>     FormalsList
%type <formal>          FormalDecl
%type <statement_list>  Statements
%type <statement>   	Statement
%type <expression>      Call
%type <expression_list> ExpList
%type <type>			Type
%type <expression>      Exp

%%

Program 	: Funcs 													{ $$ = new root_syntax($1); }
			;
Funcs   	: /*epsilon*/												{ $$ = new list_syntax<function_declaration_syntax>(); }
      		| FuncDecl Funcs											{ $$ = $2->append($1); }
			;
FuncDecl 	: RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { $$ = new function_declaration_syntax($1, $2, $4, $7); free($2); }
			;
RetType 	: Type                                                      { $$ = $1; }
        	| VOID                                                      { $$ = new type_syntax(fundamental_type::Void); }
			;
Formals 	: /*epsilon*/                                               { $$ = new list_syntax<formal_syntax>(); }
        	| FormalsList                                               { $$ = $1; }
			;
FormalsList : FormalDecl                                                { $$ = new list_syntax<formal_syntax>($1); }
			| FormalDecl COMMA FormalsList                              { $$ = $3->append($1); }
			;
FormalDecl 	: Type ID                                                   { $$ = new formal_syntax($1, $2); free($2); }
			;
Statements	: Statement	                                                { $$ = new list_syntax<statement_syntax>($1); }
 			| Statements Statement                                      { $$ = $1->append($2); }
			;
Statement	: LBRACE Statements RBRACE                                  { $$ = new block_statement_syntax($2); }
			| Type ID SC                                                { $$ = new declaration_statement_syntax($1, $2); free($2); }
			| Type ID ASSIGN Exp SC                                     { $$ = new declaration_statement_syntax($1, $2, $4); free($2); }
			| ID ASSIGN Exp SC                                          { $$ = new assignment_statement_syntax($1, $3); free($1); }
			| Call SC                                                   { $$ = new expression_statement_syntax($1); }
			| RETURN SC	                                                { $$ = new return_statement_syntax(); }
			| RETURN Exp SC                                             { $$ = new return_statement_syntax($2); }
			| IF LPAREN Exp RPAREN Statement                            { $$ = new if_statement_syntax($3, $5); }
			| IF LPAREN Exp RPAREN Statement ELSE Statement             { $$ = new if_statement_syntax($3, $5, $7); }
			| WHILE LPAREN Exp RPAREN Statement                         { $$ = new while_statement_syntax($3, $5); }
			| BREAK SC                                                  { $$ = new branch_statement_syntax(branch_type::Break); }
			| CONTINUE SC                                               { $$ = new branch_statement_syntax(branch_type::Continue); }
            ;
Call 		: ID LPAREN ExpList RPAREN                                  { $$ = new invocation_expression_syntax($1, $3); free($1); }
 			| ID LPAREN RPAREN                                          { $$ = new invocation_expression_syntax($1); free($1); }
			;
ExpList 	: Exp                                                       { $$ = new list_syntax<expression_syntax>($1); }
 			| Exp COMMA ExpList                                         { $$ = $3->append($1); }
			;
Type 		: INT                                                       { $$ = new type_syntax(fundamental_type::Int); }
			| BYTE                                                      { $$ = new type_syntax(fundamental_type::Byte); }
			| BOOL                                                      { $$ = new type_syntax(fundamental_type::Bool); }
			;
Exp 		: LPAREN Exp RPAREN	                                        { $$ = $2; }
            | Exp IF LPAREN Exp RPAREN ELSE Exp                         { $$ = new conditional_expression_syntax($1, $4, $7); }
			| Exp ADDOP Exp                                             { $$ = new arithmetic_expression_syntax($1, $3, $2); free($2); }
            | Exp MULOP Exp                                             { $$ = new arithmetic_expression_syntax($1, $3, $2); free($2); }
			| ID                                                        { $$ = new identifier_expression_syntax($1); free($1); }
			| Call                                                      { $$ = $1; }
			| NUM                                                       { $$ = new literal_expression_syntax<int>($1); }
			| NUM B                                                     { $$ = new literal_expression_syntax<char>($1); }
			| STRING                                                    { $$ = new literal_expression_syntax<std::string>($1); free($1); }
			| TRUE                                                      { $$ = new literal_expression_syntax<bool>(true); }
			| FALSE                                                     { $$ = new literal_expression_syntax<bool>(false); }
			| NOT Exp                                                   { $$ = new not_expression_syntax($2); }
			| Exp AND Exp                                               { $$ = new logical_expression_syntax($1, $3, logical_operator::And); }
			| Exp OR Exp                                                { $$ = new logical_expression_syntax($1, $3, logical_operator::Or); }
			| Exp RELOP Exp                                             { $$ = new relational_expression_syntax($1, $3, $2); free($2); }
            | Exp EQOP Exp                                              { $$ = new relational_expression_syntax($1, $3, $2); free($2); } 
			| LPAREN Type RPAREN Exp                                    { $$ = new cast_expression_syntax($2, $4); }
			;

%%

int main()
{
	return yyparse();
}

void yyerror(const char* message)
{
    output::errorSyn(yylineno);
	exit(0); 
}

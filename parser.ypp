%{

#include "SyntaxNode.hpp"

extern int yylex();
void yyerror(const char* message);
extern int yylineno;

%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token RETURN
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING

%right ASSIGN

// TODO: VERIFY IF IN RIGHT POSITION
%nonassoc IF

%left  OR
%left  AND
%left  EQOP
%left  RELOP
%left  ADDOP
%left  MULOP
%right NOT

%right LPAREN
%left  RPAREN
%left  ELSE

%%

Program 	: Funcs 													{ } // new GlobalScope($1)
			;
Funcs   	: /*epsilon*/												{ } // new FuncList()
      		| FuncDecl Funcs											{ } // $$ = $2.Concat($1)
			;
FuncDecl 	: RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE { } // FuncDeclaration($1, $4, $7)
			;
RetType 	: Type                                                      { } // $$ = $1
        	| VOID                                                      { } // new TypeNode(ObjectType::Void)
			;
Formals 	: /*epsilon*/                                               { } // new ParameterList()
        	| FormalsList                                               { } // $$ = $1
			;
FormalsList : FormalDecl                                                { } // new ParameterList($1);
			| FormalDecl COMMA FormalsList                              { } // $$ = $3.Concat($1)
			;
FormalDecl 	: Type ID                                                   { }
			;
Statements	: Statement	                                                { } // new StatementsList()
 			| Statements Statement                                      { } // $$ = $1.Concat($2)
			;
Statement	: LBRACE Statements RBRACE                                  { } // new BlockStatement($2)
			| Type ID SC                                                { } // new DeclarationStatement()
			| Type ID ASSIGN Exp SC                                     { } // new DeclarationStatement($4)
			| ID ASSIGN Exp SC                                          { } // new AssignExpression($3)
			| Call SC                                                   { } // new CallStatement($1)
			| RETURN SC	                                                { } // new ReturnStatement()
			| RETURN Exp SC                                             { } // new ReturnStatement($2)
			| IF LPAREN Exp RPAREN Statement                            { } // new IfStatement($3, $5)
			| IF LPAREN Exp RPAREN Statement ELSE Statement             { } // new IfStatement($3, $5, $7) 
			| WHILE LPAREN Exp RPAREN Statement                         { } // new WhileStatement($3, $5)
			| BREAK SC                                                  { } // new BranchStatment()
			| CONTINUE SC                                               { } // new BranchStatment()
			;
Call 		: ID LPAREN ExpList RPAREN                                  { } // new CallExpression()
 			| ID LPAREN RPAREN                                          { } // new CallExpression()
			;
ExpList 	: Exp                                                       { } // new ExpressionListSyntax($1)
 			| Exp COMMA ExpList                                         { } // $$ = $3.Concat($1)
			;
Type 		: INT                                                       { } // new TypeSyntax()
			| BYTE                                                      { } // new TypeSyntax()
			| BOOL                                                      { } // new TypeSyntax()
			;
Exp 		: LPAREN Exp RPAREN	                                        { } // $$ = $2
            | Exp IF LPAREN Exp RPAREN ELSE Exp                         { } // new ConditionalExpressionSyntax()
			| Exp ADDOP Exp                                             { } // new ArithmeticExpressionSyntax()
            | Exp MULOP Exp                                             { } // new ArithmeticExpressionSyntax()
			| ID                                                        { } // new IdentifierExpressionSyntax()
			| Call                                                      { } // $$ = $1
			| NUM                                                       { } // new LiteralExpressionSyntax()
			| NUM B                                                     { } // new LiteralExpressionSyntax()
			| STRING                                                    { } // new LiteralExpressionSyntax()
			| TRUE                                                      { } // new LiteralExpressionSyntax()
			| FALSE                                                     { } // new LiteralExpressionSyntax()
			| NOT Exp                                                   { } // new NotExpressionSyntax()
			| Exp AND Exp                                               { } // new ConditionalExpressionSyntax()
			| Exp OR Exp                                                { } // new ConditionalExpressionSyntax()
			| Exp RELOP Exp                                             { } // new ComparisonExpressionSyntax()
            | Exp EQOP Exp                                              { } // new EqualityExpressionSyntax() 
			| LPAREN Type RPAREN Exp                                    { } // new CastExpressionSyntax()
			;

%%

int main()
{ 
	return yyparse();
}

void yyerror(const char* message)
{
    //TODO: handle error
	exit(0); 
}
